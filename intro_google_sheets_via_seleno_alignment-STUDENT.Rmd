---
title: "Accessing data from Google Docs"
author: "Nathan Brouwer modified by Kayla Neal"
date: "11/15/2021"
output: html_document
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

The goal of this exercise is to make you familiar with how to download data from Google Sheets and to briefly review some key concepts R functions and coding concepts.

We'll do the following things

1. Download a Google Sheets Spreadsheet
1. Read in data from spreadsheet
1. Process and clean data

1. Generate and Explore Lists in R

1. Generate Random Sequences
1. Download FASTA files from the ncbi website

1. Explore Sequences using Dotplots and Pairwise Alignments

## Packages 

```{r}
## Google sheets download package
# comment this out when you are done
# install.packages("googlesheets4")
library(googlesheets4)

# comp bio packages
library(seqinr)
library(rentrez)
library(compbio4all)
library(Biostrings)
```


## Download data

Assign the url of the spreadsheet you want to use to a variable.

```{r}
spreadsheet_sp <- "https://docs.google.com/spreadsheets/d/1spC_ZA3_cVuvU3e_Jfcj2nEIfzp-vaP7SA5f-qwQ1pg/edit?usp=sharing" 
```

Running `gs4_deauth()` allows access to the file. It must be run to continue. 

```{r}
# be sure to run this!
googlesheets4::gs4_deauth()   # <====== MUST RUN THIS
```

Third, we download our data. The simplest way to download the coloumns individually.

#### NOTE!: sometimes Google Sheets or the function gets cranky and throws this error:

"Error in curl::curl_fetch_memory(url, handle = handle) : 
 Error in the HTTP2 framing layer"
 
If that happens, just re-run the code.

```{r}
# I include this again in case you missed is the first time : )
googlesheets4::gs4_deauth()  

# download
## NOTE: if you get an error, just run the code again
refseq_column <- read_sheet(ss = spreadsheet_sp, # the url
           sheet = "RefSeq_prot",                # the name of the worksheet
           range = "selenoprot!H1:H364",
           col_names = TRUE,
           na = "",                              # fill in empty spaces "" w/NA
           trim_ws = TRUE)
## NOTE: if you get an error, just run the code again

# for reasons we won't get into I'm going to do this
protein_refseq <- refseq_column$RefSeq_prot
```

View the first 10 elements in the column using indexing [] notation:
```{r}
protein_refseq[1:10]
```


Download the gene names
```{r}
# download
## NOTE: if you get an error, just run the code again
gene_name_column <- read_sheet(ss = spreadsheet_sp, # the url
           sheet = "gene",                # the name of the worksheet
           range = "selenoprot!A1:A364",
           col_names = TRUE,
           na = "",                              # fill in empty spaces "" w/NA
           trim_ws = TRUE)
## NOTE: if you get an error, just run the code again

# for reasons we won't get into I'm going to do this
gene <- gene_name_column$gene
```



## Explore and Parse Data

Exploring the data entails understanding what is stored, how, and what it looks like. 
```{r}
is(protein_refseq)
class(protein_refseq)
length(protein_refseq)
protein_refseq[1:10]
```



`is.na()` returns TRUE or FALSE for each element in the vector.  
```{r}
is.na(protein_refseq)
```



An easier way to visualize this is in table format.
```{r}
table(is.na(protein_refseq))
```

Explore the NA values.
```{r}
# find all of the na values and save them in a temporary variable
temp <- is.na(protein_refseq)

# visualization and save
protein_refseq[temp]

temp2 <- protein_refseq[temp]

# check the length: is the value what is expected?
length(temp2)
```

## Creating Dataframe

Create a dataframe with the data saved from the spreadsheet.
```{r}
seleno_df <- data.frame(gene = gene,
                        protein_refseq = protein_refseq)
```

Summarizing and visualizing the dataframe is important to check. `head()` is showing an NA value, that will cause problems later, so we want to get rid of those values. 
```{r}
summary(seleno_df)
head(seleno_df)
```


## Updated Dataframe

`na.omit()` will remove any row that contains an NA value. Saving this to a new dataframe will allow comparision between the two. Are the dimensions different? Should they be? Is it what is expected?
```{r}
# omit NAs
seleno_df_noNA <- na.omit(seleno_df)

# check length- should be shorter
dim(seleno_df)
dim(seleno_df_noNA)

```

## Check for Duplicates

The same gene can appear multiple times because multiple isoforms are listed.

```{r}
head(seleno_df_noNA)
```


Identify the unique genes: how many are there?
```{r}
genes_unique <- unique(seleno_df_noNA$gene)
length(genes_unique)
genes_unique

```

`unique()` just gives us the unique elements.  A related function, `duplicated()`, gives us the location of **duplicated** elements in the vector.  FALSE means "not duplicated yet" or "first instance so far".

```{r}
i.dups <- duplicated(seleno_df_noNA$gene)
```

We can remove the duplicates using a form of reverse indexing where the "!" means "not".  (You don't need to know this for the exam)

```{r}
seleno_df_noNA[!i.dups, ]
```
Make a dataframe of non-duplicated genes

```{r}
seleno_df_noDups <- seleno_df_noNA[!i.dups, ]
dim(seleno_df_noDups)
```


## Generate Random Sequences

Let's select 2 random sequences to work with.  We'll use WHICH FUNCTION? to select a random index number to get

First, lets make a vector that contains a unique number for each row of data

```{r}
indices <- 1:nrow(seleno_df_noDups)
```

This would do the same thing
```{r}
# with dim
indices <- 1:dim(seleno_df_noDups)[1]

# with length
indices <- 1:length(seleno_df_noDups$gene)
```

or hard-coded
```{r}
indices <- 1:37
```


We can then use `sample()` to select 2 random numbers from this vector.

For x = we'll use our vector of indices (1 to 37).  For size we'll use 2, since we want to pull out just 2 numbers.  For replace we'll use FALSE since we don't want to be ale to select the same number twice.
```{r}
i.random.genes <- sample(x = indices,
                         size = 2,
                         replace = FALSE)
```

Hard coded this would be
```{r}
i.random.genes <- sample(x = c(1:37),
                         size = 2,
                         replace = FALSE)
```


This gives me 2 indices values.
```{r}
i.random.genes
```


I can now use these index values to pull out 2 rows of data 
```{r}
seleno_df_noNA[i.random.genes, ]
```

Hard coded, this would be something like this for whichever genes happen to have been selected
```{r}
seleno_df_noNA[c(37,15), ]
```



## Downloading genes

Use `entrez_fetch()` from the `rentrez` R package to retrieve the FASTA file
```{r}
rentrez::entrez_fetch(id = "NP_060915.2",
                      db = "protein",
                      rettype = "fasta")

rentrez::entrez_fetch(id = "NP_001316384.1",
                      db = "protein",
                      rettype = "fasta")
```



To save the FASTA files, assign the output of the `entrez_fetch()` function to a variable
```{r}
prot1 <- rentrez::entrez_fetch(id = "NP_060915.2",
                      db = "protein",
                      rettype = "fasta")

prot2 <- rentrez::entrez_fetch(id = "NP_001316384.1",
                      db = "protein",
                      rettype = "fasta")
```

I can put them into a list like this

```{r}
# make the list
seleno_thingy <- vector("list", 1)

# add the first fasta
seleno_thingy[[1]] <- prot1

# See the result
seleno_thingy

# add the first fasta
seleno_thingy[[2]] <- prot2

# see the result
seleno_thingy

# name the 'columns' or 'elements' of the list
names(seleno_thingy) <- c("prot1", "prot2")

#Output
seleno_thingy
```


Elements of the list are accessed like this
```{r}
seleno_thingy[[1]]
```

I'll clean them with fasta_cleaner()

```{r}
# first, make a copy of the list for storing the clean data
## I'm just going to copy over the old data
seleno_thingy_clean <- seleno_thingy


# HOW TO MAKE THIS MORE COMPACT?
for(i in 1:length(seleno_thingy_clean)){
   clean_fasta_temp <- compbio4all::fasta_cleaner(seleno_thingy[[i]],
                                                       parse = T)
  
  seleno_thingy_clean[[i]] <- clean_fasta_temp
}

```

Now the data looks like this:
```{r}
seleno_thingy_clean
```
The output has the two protein sequences as labels, and then shows each part of the sequence as a distinct character. 

Explore the data. What is the first element of the list? 
```{r}
class(seleno_thingy_clean[[1]])
is(seleno_thingy_clean[[1]])
is.vector(seleno_thingy_clean[[1]])
```

## Make a dotplot

For old-times sake we can make a dotplot.  


The `dotPlot()` function takes vectors as its arguments.
```{r}
# make vectors
prot1_vector <- seleno_thingy_clean[[1]]
prot2_vector <- seleno_thingy_clean[[2]]
```

We can dotplot like this
```{r}
seqinr::dotPlot(prot1_vector,
                prot1_vector)
```


Since above we found that `is.vector()` is TRUE, we can directly call the sequences without creating new variables.
```{r, eval = F}
seqinr::dotPlot(seleno_thingy_clean[[1]],
                seleno_thingy_clean[[2]])
```


## Pairwise alignment

dotPlot likes things in a single vector, but pairwiseAlignment like a single string of characters, so as always we have to process the data.


Take the each element in the list and store it as one string of characters using the `paste()` function. The argument `sep = ""` ensures that there will be no space between each character in the new string.
```{r}
prot1_str <- paste(seleno_thingy_clean[[1]],sep = "", collapse = "")
prot2_str <- paste(seleno_thingy_clean[[2]],sep = "", collapse = "")
```


So now things look like this:
```{r}
prot1_str
```
The output should look like one long string, each amino acid single character one after the other. 

Protein alignments need a amino acid transition matrix, and we need to use data() to bring those up into active memory (VERY IMPORTANT STEP!)

```{r}
data(BLOSUM50)
```

The alignment
```{r}
align_out <- Biostrings::pairwiseAlignment(pattern = prot1_str, 
                              subject = prot2_str, 
                              type = "global",
                              gapOpening = -9.5,
                              gapExtension = -0.5)
```

R has a standard way to print out pairwise alignments. However, since the sequences are so long, it only shows the beginning and end of the alignment and the score. 
```{r}
align_out
```


The `print_pairwise_alignment()` function in the Compbio4all package can be used to view the entire alignment,.
```{r}

compbio4all::print_pairwise_alignment(align_out)

```

These are two randomly chosen sequences, so the alignment should be pretty different. The expectation would be a small or negative score with lots of '-' in the visualization of the alignment.

The score is negative, but on its own that means dissimilar. It doesn't alone quantify what the relationship between the sequences is. 
```{r}
score(align_out)
```

pid gives us the percent identity between the two sequences.
```{r}
pid(align_out)

```

Of course, pid can be calculated several ways 
```{r}
pid(align_out,type = "PID1")
pid(align_out,type = "PID2")
pid(align_out,type = "PID3")
pid(align_out,type = "PID4")
```
The problem with different calculations of pid can be seen when it is undefined in context. For example, PID1 suggests 7% identity, but PID2 suggests 91%. What's the difference? The `pid` help file tells us PID1 is calculated over the number of aligned and internal gap positions whereas PID2 is calculated over just aligned positions. It is important to know that PID2 doesn't consider gaps. If the way the pid was calculated wasn't defined, it would be misleading to analyze. 
